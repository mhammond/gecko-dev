// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

"use strict";

var EXPORTED_SYMBOLS = [];

// UniFFIRustCallResult.code values
const CALL_SUCCESS = 0;
const CALL_ERROR = 1;
const CALL_INTERNAL_ERROR = 2;

// Write/Read data to/from an ArrayBuffer
class ArrayBufferDataStream {
    constructor(arrayBuffer) {
        this.dataView = new DataView(arrayBuffer);
        this.pos = 0;
    }

    readUint8() {
        let rv = this.dataView.getUint8(this.pos);
        this.pos += 1;
        return rv;
    }

    readUint16() {
        let rv = this.dataView.getUint16(this.pos);
        this.pos += 2;
        return rv;
    }

    readUint32() {
        let rv = this.dataView.getUint32(this.pos);
        this.pos += 4;
        return rv;
    }

    readUint64() {
        let rv = this.dataView.getUint64(this.pos);
        this.pos += 8;
        return rv;
    }

    readInt8() {
        let rv = this.dataView.getInt8(this.pos);
        this.pos += 1;
        return rv;
    }

    readInt16() {
        let rv = this.dataView.getInt16(this.pos);
        this.pos += 2;
        return rv;
    }

    readInt32() {
        let rv = this.dataView.getInt32(this.pos);
        this.pos += 4;
        return rv;
    }

    readInt64() {
        let rv = this.dataView.getInt64(this.pos);
        this.pos += 8;
        return rv;
    }

    readFloat32() {
        let rv = this.dataView.getFloat32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeFloat32(value) {
        this.dataView.setFloat32(this.pos, value);
        this.pos += 4;
    }

    readFloat64() {
        let rv = this.dataView.getFloat64(this.pos);
        this.pos += 8;
        return rv;
    }

    writeFloat64(value) {
        this.dataView.setFloat64(this.pos, value);
        this.pos += 8;
    }



    // TODO: write more methods
}


function handleRustResult(result, liftCallback, liftErrCallback) {
    switch (result.code) {
        case CALL_SUCCESS:
            return liftCallback(result.data);

        case CALL_ERROR:
            throw liftErrCallback(result.data);

        case CALL_INTERNAL_ERROR:
            let message = result.internalErrorMessage;
            if (message) {
                throw new UniFFIInternalError(message);
            } else {
                throw new UniFFIInternalError("Unknown error");
            }

        default:
            throw new UniFFIError(`Unexpected status code: ${result.code}`);
    }
}

class UniFFIError {
    constructor(message) {
        this.message = message;
    }
}

class UniFFIInternalError extends UniFFIError {}

// Base class for FFI converters that lift/lower by reading/writing to an ArrayBuffer
class FfiConverterArrayBuffer {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }

    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize());
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }
}


class FfiConverterF64 {
    static computeSize() {
        return 8;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeFloat64(value)
    }
    static read(dataStream) {
        return dataStream.readFloat64()
    }
}


class Line {
    constructor(start,end) {
        this.start = start;
        this.end = end;
    }
}

class FfiConverterTypeLine {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }
    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize());
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }
    static read(dataStream) {
        return new Line(
            FfiConverterTypePoint.read(dataStream), 
            FfiConverterTypePoint.read(dataStream) 
        );
    }
    static write(dataStream, value) {
        FfiConverterTypePoint.write(dataStream, value.start);
        FfiConverterTypePoint.write(dataStream, value.end);
    }

    static computeSize() {
        let totalSize = 0;
        totalSize += FfiConverterTypePoint.computeSize();
        totalSize += FfiConverterTypePoint.computeSize();
        return totalSize
    }
}

EXPORTED_SYMBOLS.push("Line");

class Point {
    constructor(coordX,coordY) {
        this.coordX = coordX;
        this.coordY = coordY;
    }
}

class FfiConverterTypePoint {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }
    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize());
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }
    static read(dataStream) {
        return new Point(
            FfiConverterF64.read(dataStream), 
            FfiConverterF64.read(dataStream) 
        );
    }
    static write(dataStream, value) {
        FfiConverterF64.write(dataStream, value.coordX);
        FfiConverterF64.write(dataStream, value.coordY);
    }

    static computeSize() {
        let totalSize = 0;
        totalSize += FfiConverterF64.computeSize();
        totalSize += FfiConverterF64.computeSize();
        return totalSize
    }
}

EXPORTED_SYMBOLS.push("Point");class FfiConverterOptionalTypePoint extends FfiConverterArrayBuffer {
    static read(dataStream) {
        const code = dataStream.readUint8(0);
        switch (code) {
            case 0:
                return null
            case 1:
                return FfiConverterTypePoint.read(dataStream)
            default:
                throw UniFFIError(`Unexpected code: ${code}`);
        }
    }

    static write(dataStream, value) {
        if (!value) {
            dataStream.writeUint8(0);
        }
        dataStream.writeUint8(1);
        FfiConverterTypePoint.write(dataStream, value)
    }

    static computeSize() {
        return 1 + FfiConverterTypePoint.computeSize()
    }
}


function gradient(ln) {
    const liftResult = (result) => FfiConverterF64.lift(result)
    const liftError = null; // TODO
    const callResult = GeometryScaffolding.geometryEb69Gradient(FfiConverterTypeLine.lower(ln),
    )
    return callResult.then((result) => handleRustResult(result,  liftResult, liftError));
}

EXPORTED_SYMBOLS.push("gradient");
function intersection(ln1,ln2) {
    const liftResult = (result) => FfiConverterOptionalTypePoint.lift(result)
    const liftError = null; // TODO
    const callResult = GeometryScaffolding.geometryEb69Intersection(FfiConverterTypeLine.lower(ln1),FfiConverterTypeLine.lower(ln2),
    )
    return callResult.then((result) => handleRustResult(result,  liftResult, liftError));
}

EXPORTED_SYMBOLS.push("intersection");