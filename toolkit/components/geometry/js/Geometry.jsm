// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

"use strict";

var EXPORTED_SYMBOLS = [];

// UniFFIRustCallResult.code values
const CALL_SUCCESS = 0;
const CALL_ERROR = 1;
const CALL_INTERNAL_ERROR = 2;

// Write/Read data to/from an ArrayBuffer
class ArrayBufferDataStream {
    constructor(arrayBuffer) {
        this.dataView = new DataView(arrayBuffer);
        this.pos = 0;
    }

    readUint8() {
        let rv = this.dataView.getUint8(this.pos);
        this.pos += 1;
        return rv;
    }

    readUint16() {
        let rv = this.dataView.getUint16(this.pos);
        this.pos += 2;
        return rv;
    }

    readUint32() {
        let rv = this.dataView.getUint32(this.pos);
        this.pos += 4;
        return rv;
    }

    readUint64() {
        let rv = this.dataView.getUint64(this.pos);
        this.pos += 8;
        return rv;
    }

    readInt8() {
        let rv = this.dataView.getInt8(this.pos);
        this.pos += 1;
        return rv;
    }

    readInt16() {
        let rv = this.dataView.getInt16(this.pos);
        this.pos += 2;
        return rv;
    }

    readInt32() {
        let rv = this.dataView.getInt32(this.pos);
        this.pos += 4;
        return rv;
    }

    readInt64() {
        let rv = this.dataView.getInt64(this.pos);
        this.pos += 8;
        return rv;
    }

    readFloat32() {
        let rv = this.dataView.getFloat32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeFloat32(value) {
        this.dataView.setFloat32(this.pos, value);
        this.pos += 4;
    }

    readFloat64() {
        let rv = this.dataView.getFloat64(this.pos);
        this.pos += 8;
        return rv;
    }

    writeFloat64(value) {
        this.dataView.setFloat64(this.pos, value);
        this.pos += 8;
    }

    writeUint8(value) {
      this.dataView.setUint8(this.pos, value);
      this.pos += 1;
    }

    writeUint32(value) {
      this.dataView.setUint32(this.pos, value);
      this.pos += 4;
    }
  
    writeUint8Array(value) {
      for (const byte of value) {
        this.writeUint8(byte);
      }
    }

    readUint8Array(len) {
      const arr = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        arr[i] = this.readUint8();
      }
      return arr;
    }
  
    // TODO: write more methods
}


function handleRustResult(result, liftCallback, liftErrCallback) {
    switch (result.code) {
        case CALL_SUCCESS:
            return liftCallback(result.data);

        case CALL_ERROR:
            throw liftErrCallback(result.data);

        case CALL_INTERNAL_ERROR:
            let message = result.internalErrorMessage;
            if (message) {
                throw new UniFFIInternalError(message);
            } else {
                throw new UniFFIInternalError("Unknown error");
            }

        default:
            throw new UniFFIError(`Unexpected status code: ${result.code}`);
    }
}

class UniFFIError {
    constructor(message) {
        this.message = message;
    }
}

class UniFFIInternalError extends UniFFIError {}

// Base class for FFI converters that lift/lower by reading/writing to an ArrayBuffer
class FfiConverterArrayBuffer {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }

    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize(value));
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }
}

class FfiConverterU32 {
    static computeSize() {
        return 4;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeUint32(value)
    }
    static read(dataStream) {
        return dataStream.readUint32()
    }
}class FfiConverterF64 {
    static computeSize() {
        return 8;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeFloat64(value)
    }
    static read(dataStream) {
        return dataStream.readFloat64()
    }
}

class FfiConverterString {
    static lift(buf) {
        const decoder = new TextDecoder();
        const utf8Arr = new Uint8Array(buf);
        return decoder.decode(utf8Arr);
    }
    static lower(value) {
        const encoder = new TextEncoder();
        return encoder.encode(value).buffer;
    }

    static write(dataStream, value) {
        const encoder = new TextEncoder();
        const utf8Arr = encoder.encode(value);
        dataStream.writeUint32(utf8Arr.length);
        dataStream.writeUint8Array(utf8Arr);
    }

    static read(dataStream) {
        const decoder = new TextDecoder();
        const size = dataStream.readUint32();
        const utf8Arr = dataStream.readUint8Array(size);
        return decoder.decode(utf8Arr);
    }

    static computeSize(value) {
        const encoder = new TextEncoder();
        return 4 + encoder.encode(value).length
    }
}

class Line {
    constructor(start,end) {
        this.start = start;
        this.end = end;
    }
}

class FfiConverterTypeLine {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }
    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize(value));
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }
    static read(dataStream) {
        return new Line(
            FfiConverterTypePoint.read(dataStream), 
            FfiConverterTypePoint.read(dataStream) 
        );
    }
    static write(dataStream, value) {
        FfiConverterTypePoint.write(dataStream, value.start);
        FfiConverterTypePoint.write(dataStream, value.end);
    }

    static computeSize(value) {
        let totalSize = 0;
        totalSize += FfiConverterTypePoint.computeSize(value.start);
        totalSize += FfiConverterTypePoint.computeSize(value.end);
        return totalSize
    }
}

EXPORTED_SYMBOLS.push("Line");

class Point {
    constructor(coordX,coordY,description) {
        this.coordX = coordX;
        this.coordY = coordY;
        this.description = description;
    }
}

class FfiConverterTypePoint {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }
    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize(value));
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }
    static read(dataStream) {
        return new Point(
            FfiConverterF64.read(dataStream), 
            FfiConverterF64.read(dataStream), 
            FfiConverterString.read(dataStream) 
        );
    }
    static write(dataStream, value) {
        FfiConverterF64.write(dataStream, value.coordX);
        FfiConverterF64.write(dataStream, value.coordY);
        FfiConverterString.write(dataStream, value.description);
    }

    static computeSize(value) {
        let totalSize = 0;
        totalSize += FfiConverterF64.computeSize(value.coordX);
        totalSize += FfiConverterF64.computeSize(value.coordY);
        totalSize += FfiConverterString.computeSize(value.description);
        return totalSize
    }
}

EXPORTED_SYMBOLS.push("Point");


class ComplexGeometryError extends Error {}
EXPORTED_SYMBOLS.push("ComplexGeometryError");


class NoIntersection extends ComplexGeometryError {
    
    constructor(
        reason,
        code,
        ...params
        ) {
            super(...params);
            this.reason = reason;
            this.code = code;
        }
}
EXPORTED_SYMBOLS.push("NoIntersection");

class FfiConverterTypeComplexGeometryError extends FfiConverterArrayBuffer {
    static read(dataStream) {
        switch (dataStream.readInt32()) {
            case 1:
                return new NoIntersection(
                    FfiConverterString.read(dataStream),
                    FfiConverterU32.read(dataStream)
                    );
            default:
                return new Error("Unknown ComplexGeometryError variant");
        }
    }
}


class GeometryError extends Error {}
EXPORTED_SYMBOLS.push("GeometryError");


class UndefinedGradient extends GeometryError {
    
    constructor(message, ...params) {
        super(...params);
        this.message = message;
    }
}
EXPORTED_SYMBOLS.push("UndefinedGradient");

class FfiConverterTypeGeometryError extends FfiConverterArrayBuffer {
    static read(dataStream) {
        switch (dataStream.readInt32()) {
            case 1:
                return new UndefinedGradient(FfiConverterString.read(dataStream));
            default:
                return new Error("Unknown GeometryError variant");
        }
    }
}class FfiConverterSequencestring extends FfiConverterArrayBuffer {
    static read(dataStream) {
        const len = dataStream.readUint32();
        const arr = [];
        for (let i = 0; i < len; i++) {
            arr.push(FfiConverterString.read(dataStream));
        }
        return arr;
    }

    static write(dataStream, value) {
        dataStream.writeUint32(value.length);
        value.forEach((innerValue) => {
            FfiConverterString.write(dataStream, innerValue);
        })
    }

    static computeSize(value) {
        // The size of the length
        let size = 4;
        for (const innerValue of value) {
            size += FfiConverterString.computeSize(innerValue);
        }
        return size;
    }
}


class FfiConverterMapstring extends FfiConverterArrayBuffer {
    static read(dataStream) {
        const len = dataStream.readUint32();
        const map = {};
        for (let i = 0; i < len; i++) {
            const key = FfiConverterString.read(dataStream);
            const value = FfiConverterString.read(dataStream);
            map[key] = value;
        }

        return map;
    }

    static write(dataStream, value) {
        dataStream.writeUint32(Object.keys(value).length);
        for (const key in value) {
            FfiConverterString.write(dataStream, key);
            FfiConverterString.write(dataStream, value[key]);
        }
    }

    static computeSize(value) {
        // The size of the length
        let size = 4;
        for (const key in value) {
            size += FfiConverterString.computeSize(key);
            size += FfiConverterString.computeSize(value[key]);
        }
        return size;
    }
}


function gradient(ln) {
    const liftResult = (result) => FfiConverterF64.lift(result);
    const liftError = (data) => FfiConverterTypeGeometryError.lift(data); // TODO

    const callResult = GeometryScaffolding.geometryC24cGradient(FfiConverterTypeLine.lower(ln),
    )
    return callResult.then((result) => handleRustResult(result,  liftResult, liftError));
}

EXPORTED_SYMBOLS.push("gradient");
function intersection(ln1,ln2) {
    const liftResult = (result) => FfiConverterTypePoint.lift(result);
    const liftError = (data) => FfiConverterTypeComplexGeometryError.lift(data); // TODO

    const callResult = GeometryScaffolding.geometryC24cIntersection(FfiConverterTypeLine.lower(ln1),FfiConverterTypeLine.lower(ln2),
    )
    return callResult.then((result) => handleRustResult(result,  liftResult, liftError));
}

EXPORTED_SYMBOLS.push("intersection");
function stringRound(s) {
    const liftResult = (result) => FfiConverterString.lift(result);
    const liftError = null;

    const callResult = GeometryScaffolding.geometryC24cStringRound(FfiConverterString.lower(s),
    )
    return callResult.then((result) => handleRustResult(result,  liftResult, liftError));
}

EXPORTED_SYMBOLS.push("stringRound");
function stringRecordRound(p) {
    const liftResult = (result) => FfiConverterTypePoint.lift(result);
    const liftError = null;

    const callResult = GeometryScaffolding.geometryC24cStringRecordRound(FfiConverterTypePoint.lower(p),
    )
    return callResult.then((result) => handleRustResult(result,  liftResult, liftError));
}

EXPORTED_SYMBOLS.push("stringRecordRound");
function arrRound(arr,size) {
    const liftResult = (result) => FfiConverterSequencestring.lift(result);
    const liftError = null;

    const callResult = GeometryScaffolding.geometryC24cArrRound(FfiConverterSequencestring.lower(arr),FfiConverterU32.lower(size),
    )
    return callResult.then((result) => handleRustResult(result,  liftResult, liftError));
}

EXPORTED_SYMBOLS.push("arrRound");
function mapRound(map,size) {
    const liftResult = (result) => FfiConverterMapstring.lift(result);
    const liftError = null;

    const callResult = GeometryScaffolding.geometryC24cMapRound(FfiConverterMapstring.lower(map),FfiConverterU32.lower(size),
    )
    return callResult.then((result) => handleRustResult(result,  liftResult, liftError));
}

EXPORTED_SYMBOLS.push("mapRound");